---
title: "Rustã§ä½œã‚‹è‡ªä½œè¨€èª(10) ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹"
emoji: "ğŸ™Œ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "è‡ªä½œè¨€èª"]
published: true
---

[ä»Šå›ã®ä½œæ¥­ãƒ–ãƒ©ãƒ³ãƒ](https://github.com/taka231/lunalang/tree/writing_interpreter_in_rust_10)
# ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã®å®šç¾©ã®æ–‡æ³•
ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã™ã€‚
```
enum Hoge {
    Foo(Int, String),
    Bar
};
```

ã“ã®ASTã¯ã€æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã—ãŸã€‚
```rust
#[derive(PartialEq, Eq, Debug, Clone)]
pub enum Statement {
    Assign(String, Expr),
    TypeDef(String, Vec<ConstructorDef>),
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ConstructorDef {
    pub name: String,
    pub args: Vec<Type>,
}
```

# ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã®å®šç¾©æ–‡ã®ãƒ‘ãƒ¼ã‚µãƒ¼
```rust
pub fn statement_typedef(input: &str) -> IResult<&str, Statement> {
    let (input, _) = keyword("enum")(input)?;
    let (input, id) = identifier_start_with_capital(input)?;
    let (input, _) = symbol("{")(input)?;
    let (input, constructors) = separated_list0(symbol(","), |input| {
        let (input, name) = identifier_start_with_capital(input)?;
        let (input, args) = opt(|input| {
            let (input, _) = symbol("(")(input)?;
            let (input, args) = separated_list0(symbol(","), parser_type)(input)?;
            let (input, _) = symbol(")")(input)?;
            Ok((input, args))
        })(input)?;
        match args {
            Some(args) => Ok((input, ConstructorDef { name, args })),
            None => Ok((input, ConstructorDef { name, args: vec![] })),
        }
    })(input)?;
    let (input, _) = symbol("}")(input)?;
    let (input, _) = symbol(";")(input)?;
    Ok((input, Statement::TypeDef(id, constructors)))
}
```

`parser_type`é–¢æ•°ã¯ã€å‹ã®ãƒ‘ãƒ¼ã‚µãƒ¼ã§ã‚ã‚‹ã€‚
```rust
pub fn parser_type(input: &str) -> IResult<&str, Type> {
    let (input, id) = identifier_start_with_capital(input)?;
    Ok((input, Type::TType(id)))
}
```
ç¾çŠ¶ã§ã¯é–¢æ•°ã®å‹`->`ã‚„Vectorå‹ãªã©ã«å¯¾å¿œã—ã¦ã„ãªã„ã€‚

# å˜ç›¸å‹
0å¼•æ•°ã®ä¸€èˆ¬ã®å˜ç›¸å‹ã‚’æ¬¡ã®ã‚ˆã†ã«è¡¨ã™ã“ã¨ã«ã™ã‚‹ã€‚
```rust
pub enum Type {
    TType(String),
}
```
ã“ã‚Œã«ä¼´ã„ã€Stringã‚„Intãªã©ã‚’`Type::TType("String".to_owned())`ã‚„`Type::TType("Int".to_owned())`ã«æ›¸ãæ›ãˆã‚‹ã€‚

# å‹å®šç¾©ã®å‹æ¨è«–éƒ¨ã§ã®å‡¦ç†
å‹å®šç¾©ã®AST`Statement::TypeDef`ã¯ã€`typeinfer_statement`ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¦æ¬¡ã®ã‚ˆã†ãªå‡¦ç†ãŒãªã•ã‚Œã‚‹ã€‚
```rust
Statement::TypeDef(type_name, constructor_def_vec) => {
    for ConstructorDef { name, args } in constructor_def_vec {
        self.env.borrow_mut().insert(
            name.to_owned(),
            args.iter()
                .rev()
                .fold(Type::ttype(type_name), |acm, ty| t_fun(ty.clone(), acm)),
        )
    }
}
```
å…·ä½“çš„ã«ã¯ã€å‹å®šç¾©ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å„ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‹ç’°å¢ƒã«åŠ ãˆã¦ã„ã‚‹ã€‚
ä¾‹ã¨ã—ã¦ã€æ¬¡ã®ã‚ˆã†ãªå‹å®šç¾©ãŒã‚ã£ãŸå ´åˆã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã‚‹ã€‚
```
enum OptionInt {
    Some(Int),
    None
};
```
ã“ã®å ´åˆã€å‹ç’°å¢ƒã«ã¯`Some`ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å‹`Int -> OptionInt`ã¨`None`ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å‹`OptionInt`ãŒåŠ ãˆã‚‰ã‚Œã‚‹ã€‚

# å‹å®šç¾©ã®è©•ä¾¡éƒ¨ã§ã®å‡¦ç†
ã¾ãšã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¡¨ã™å€¤ã‚’å®šç¾©ã™ã‚‹ã€‚
```rust
VConstructor(String, Vec<Value>),
```

ãã—ã¦ã€å‹å®šç¾©ã®AST`Statement::TypeDef`ã®å ´åˆã®å‡¦ç†ã‚’`eval_statement`ãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ ã™ã‚‹ã€‚
```rust
Statement::TypeDef(_, constructor_def_vec) => {
    for ConstructorDef { name, args } in constructor_def_vec {
        self.env.borrow_mut().insert(
            name.to_owned(),
            Value::VConstructor(name.to_owned(), vec![]),
        )
    }
    Ok(())
}
```

ãã—ã¦ã€é–¢æ•°é©ç”¨ã®è©•ä¾¡ã«ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å ´åˆã‚’è¿½åŠ ã—ã¦ãŠãã€‚(ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯`Foo(3)`ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã®ã§ã€æ§‹æ–‡è§£æã™ã‚‹ã¨é–¢æ•°é©ç”¨ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹ã€‚)

```rust
fn fun_app_helper(&self, v1: Value, v2: Value) -> Result<Value, EvalError> {
    match v1 {
        ...
        Value::VConstructor(name, args) => {
            let mut mut_args = args;
            mut_args.push(v2);
            Ok(Value::VConstructor(name, mut_args))
        }
        _ => Err(EvalError::InternalTypeError),
    }
}
```

# å‹ã®æ§‹æ–‡è§£æ
ã•ã¦ã€ä»Šã®æ‰€å˜ç´”ãªå‹(`Int`ã‚„`Hoge`ç­‰)ã®ã¿ã—ã‹æ§‹æ–‡è§£æå‡ºæ¥ãªã„ã®ã‚’ã€é–¢æ•°ã®å‹ã‚„Vectorå‹ãªã©ã‚’æ§‹æ–‡è§£æå‡ºæ¥ã‚‹ã‚ˆã†ã«ã—ã¦ã„ãã€‚(å‹å¤‰æ•°ã‚’å«ã‚€å‹ã«ã¤ã„ã¦ã¯ã€ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã§å‹å¤‰æ•°ã‚’å«ã‚€å‹ãŒå®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹æ‹¡å¼µã‚’æ–½ã™ã¨ãã«ä¸€ç·’ã«æ§‹æ–‡è§£æã‚’å®Ÿè£…ã™ã‚‹ã€‚)

```rust
pub fn parser_type_init(input: &str) -> IResult<&str, Type> {
    parser_fun_type(input)
}

pub fn parser_fun_type(input: &str) -> IResult<&str, Type> {
    let (input, t1) = parser_type(input)?;
    let (input, t2) = opt(|input| {
        let (input, _) = symbol("->")(input)?;
        let (input, t2) = parser_fun_type(input)?;
        Ok((input, t2))
    })(input)?;
    match t2 {
        Some(t2) => Ok((input, Type::TFun(Box::new(t1), Box::new(t2)))),
        None => Ok((input, t1)),
    }
}

pub fn parser_type(input: &str) -> IResult<&str, Type> {
    alt((
        delimited(symbol("("), parser_type_init, symbol(")")),
        parser_ref_type,
        parser_vector_type,
        parser_simple_type,
        parser_unit_type,
    ))(input)
}
```
ã¾ãšã€`parser_type_init`ãŒã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã¨ãªã£ã¦ã„ã‚‹ã€‚ãã—ã¦`parser_fun_type`ã§ã¯é–¢æ•°ã®å‹ã®æ§‹æ–‡è§£æãŒã•ã‚Œã‚‹(->ã¯å³çµåˆ)ã€‚`parser_type`ã§ã¯ã€Unitå‹ã€Vectorå‹ã€Refå‹ã€æ™®é€šã®å‹(`Int`ã‚„`Hoge`ãªã©)ã€æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸå‹ã®æ§‹æ–‡è§£æãŒãªã•ã‚Œã‚‹ã€‚

# matchå¼ã®AST

ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã®å¼(matchå¼ã¨å‘¼ã¶ã“ã¨ã«ã—ã¾ã™)ã®æ–‡æ³•ã¯æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚
```rust
(å¼) match {
    (ãƒ‘ã‚¿ãƒ¼ãƒ³) => (å¼),
    ...
    (ãƒ‘ã‚¿ãƒ¼ãƒ³) => (å¼)
}
```
matchå¼ã®ASTã¯æ¬¡ã®ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚
```rust
pub enum Expr {
    ...
    EMatch(Box<Expr>, Vec<(Pattern, Expr)>)
}

// Patternã®å®šç¾©
#[derive(PartialEq, Eq, Debug, Clone)]
pub enum Pattern {
    PValue(Expr),
    PConstructor(String, Vec<Pattern>),
    PVar(String),
}
```

# matchå¼ã®ãƒ‘ãƒ¼ã‚µãƒ¼

ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯(ç¾çŠ¶ã§ã¯)ä¸‰ç¨®é¡ã‚ã‚Šã¾ã™ã€‚
- å€¤ãƒ‘ã‚¿ãƒ¼ãƒ³
- ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ‘ã‚¿ãƒ¼ãƒ³
- å¤‰æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³

å€¤ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ãã®åã®é€šã‚Š3ã‚„()ç­‰ã®å€¤ã®ã“ã¨ã§ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€`Some()`ç­‰ã®ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ã“ã¨ã§ã™ã€‚ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãã®å¼•æ•°ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŒã¤å ´åˆãŒã‚ã‚Šã¾ã™ã€‚å¤‰æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãã®å¤‰æ•°ã«ã€ãƒãƒƒãƒã™ã‚‹å€¤ãŒæ ¼ç´ã•ã‚Œã¾ã™ã€‚

ãã‚Œãã‚Œã®ãƒ‘ãƒ¼ã‚µãƒ¼ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
```rust
pub fn parser_pattern(input: &str) -> IResult<&str, Pattern> {
    alt((
        parser_constructor_pattern,
        parser_variable_pattern,
        parser_value_pattern,
    ))(input)
}

pub fn parser_variable_pattern(input: &str) -> IResult<&str, Pattern> {
    let (input, var) = identifier(input)?;
    Ok((input, Pattern::PVar(var)))
}

pub fn parser_value_pattern(input: &str) -> IResult<&str, Pattern> {
    let (input, expr) = alt((expr_int, parser_unit))(input)?;
    Ok((input, Pattern::PValue(expr)))
}

pub fn parser_constructor_pattern(input: &str) -> IResult<&str, Pattern> {
    let (input, name) = identifier_start_with_capital(input)?;
    let (input, args) = opt(|input| {
        delimited(
            symbol("("),
            separated_list0(symbol(","), parser_pattern),
            symbol(")"),
        )(input)
    })(input)?;
    match args {
        Some(args) => Ok((input, Pattern::PConstructor(name, args))),
        None => Ok((input, Pattern::PConstructor(name, vec![]))),
    }
}
```

# matchå¼ã®å‹æ¨è«–

matchå¼ã®å‹æ¨è«–ã®å¤§æ ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
```rust
Expr::EMatch(expr, match_arms) => {
    let ty = self.typeinfer_expr(expr)?;
    if match_arms.len() == 0 {
        return Ok(ty);
    }
    let result_ty = self.newTVar();
    for (pattern, expr) in match_arms {
        let mut typeinfer = TypeInfer::from(
            TypeEnv::new_enclosed_env(Rc::clone(&self.env)),
            self.unassigned_num,
            self.level,
        );
        typeinfer.typeinfer_pattern(&pattern, &ty)?;
        unify(&result_ty, &typeinfer.typeinfer_expr(expr)?)?;
        self.unassigned_num = typeinfer.unassigned_num
    }
    Ok(result_ty)
}
```
`typeinfer_pattern`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒexprã®å‹ã«ãƒãƒƒãƒã™ã‚‹ã‹ã‚’ç¢ºèªã—ã€å¤‰æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒç¾ã‚ŒãŸã¨ãã¯ãã®å¤‰æ•°ã¨ãã®å‹ã‚’å‹ç’°å¢ƒã«è¿½åŠ ã—ã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã§ã¯ãƒãƒƒãƒã‚¢ãƒ¼ãƒ ã”ã¨ã«ã‚¹ã‚³ãƒ¼ãƒ—ãŒåˆ‡ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

`typeinfer_pattern`ãƒ¡ã‚½ãƒƒãƒ‰ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
```rust
fn typeinfer_pattern(&mut self, pattern: &Pattern, ty: &Type) -> Result<(), TypeInferError> {
    match pattern {
        Pattern::PValue(value) => unify(&self.typeinfer_expr(value)?, ty)?,
        Pattern::PConstructor(name, patterns) => {
            let constructor_ty = self.env.borrow().get(&name)?;
            let (args, result) = constructor_ty.separate_to_args_and_resulttype();
            if args.len() != patterns.len() {
                return Err(TypeInferError::InvalidArgumentPatternError(
                    args.len(),
                    patterns.len(),
                ));
            }
            for i in 0..args.len() {
                self.typeinfer_pattern(&patterns[i], &args[i])?;
            }
            unify(&result, ty)?;
        }
        Pattern::PVar(var_name) => {
            let new_type = self.newTVar();
            unify(&new_type, ty)?;
            self.env.borrow_mut().insert(var_name.clone(), new_type)
        }
    };
    Ok(())
}
```

# matchå¼ã®è©•ä¾¡
```rust
Expr::EMatch(expr, match_arms) => {
    let expr = self.eval_expr(*expr)?;
    for (pattern, expr_arm) in match_arms {
        let eval = Eval::from(Environment::new_enclosed_env(Rc::clone(&self.env)));
        if eval.expr_match_pattern(&expr, &pattern)? == true {
            return eval.eval_expr(expr_arm);
        }
    }
    Err(EvalError::NotMatchAnyPattern)
}
```
exprãŒpatternã«ãƒãƒƒãƒã™ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã€ãƒãƒƒãƒã™ã‚‹å ´åˆã¯ãƒãƒƒãƒã‚¢ãƒ¼ãƒ ã®ä¸­èº«ã®å¼ã‚’è©•ä¾¡ã—ã¾ã™ã€‚ãƒãƒƒãƒã‚¢ãƒ¼ãƒ ã”ã¨ã«ã‚¹ã‚³ãƒ¼ãƒ—ã‚’åˆ‡ã£ã¦ã„ã¾ã™ã€‚

ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã™ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã—ã¦ã„ã‚‹ã®ã¯ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚
```rust
fn expr_match_pattern(&self, expr: &Value, pattern: &Pattern) -> Result<bool, EvalError> {
    match pattern {
        Pattern::PValue(value) => {
            let value = self.eval_expr(value.clone())?;
            Ok(value == *expr)
        }
        Pattern::PConstructor(name, patterns) => {
            if let Value::VConstructor(constructor_name, args) = expr {
                if constructor_name != name {
                    return Ok(false);
                } else if patterns.len() != args.len() {
                    return Err(EvalError::InternalTypeError);
                }
                let mut result = true;
                for i in 0..patterns.len() {
                    result = result && self.expr_match_pattern(&args[i], &patterns[i])?;
                }
                Ok(result)
            } else {
                Ok(false)
            }
        }
        Pattern::PVar(var_name) => {
            self.env.borrow_mut().insert(var_name.clone(), expr.clone());
            Ok(true)
        }
    }
}
```

# ã¾ã¨ã‚
ä»¥ä¸Šã§ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã¨ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãŒå®Ÿè£…ã§ãã¾ã—ãŸã€‚æ¬¡å›ã¯ã€ã“ã®å‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹é€ çš„å‹ã‚·ã‚¹ãƒ†ãƒ ã«å¤‰æ›´ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

---
title: "Rustã§ä½œã‚‹è‡ªä½œè¨€èª(10) ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹(1)"
emoji: "ğŸ™Œ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "è‡ªä½œè¨€èª"]
published: true
---
# ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã®å®šç¾©ã®æ–‡æ³•
ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã™ã€‚
```
enum Hoge {
    Foo(Int, String),
    Bar
};
```

ã“ã®ASTã¯ã€æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã—ãŸã€‚
```rust
#[derive(PartialEq, Eq, Debug, Clone)]
pub enum Statement {
    Assign(String, Expr),
    TypeDef(String, Vec<ConstructorDef>),
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ConstructorDef {
    pub name: String,
    pub args: Vec<Type>,
}
```

# ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã®å®šç¾©æ–‡ã®ãƒ‘ãƒ¼ã‚µãƒ¼
```rust
pub fn statement_typedef(input: &str) -> IResult<&str, Statement> {
    let (input, _) = keyword("enum")(input)?;
    let (input, id) = identifier_start_with_capital(input)?;
    let (input, _) = symbol("{")(input)?;
    let (input, constructors) = separated_list0(symbol(","), |input| {
        let (input, name) = identifier_start_with_capital(input)?;
        let (input, args) = opt(|input| {
            let (input, _) = symbol("(")(input)?;
            let (input, args) = separated_list0(symbol(","), parser_type)(input)?;
            let (input, _) = symbol(")")(input)?;
            Ok((input, args))
        })(input)?;
        match args {
            Some(args) => Ok((input, ConstructorDef { name, args })),
            None => Ok((input, ConstructorDef { name, args: vec![] })),
        }
    })(input)?;
    let (input, _) = symbol("}")(input)?;
    let (input, _) = symbol(";")(input)?;
    Ok((input, Statement::TypeDef(id, constructors)))
}
```

`parser_type`é–¢æ•°ã¯ã€å‹ã®ãƒ‘ãƒ¼ã‚µãƒ¼ã§ã‚ã‚‹ã€‚
```rust
pub fn parser_type(input: &str) -> IResult<&str, Type> {
    let (input, id) = identifier_start_with_capital(input)?;
    Ok((input, Type::TType(id)))
}
```
ç¾çŠ¶ã§ã¯é–¢æ•°ã®å‹`->`ã‚„Vectorå‹ãªã©ã«å¯¾å¿œã—ã¦ã„ãªã„ã€‚

# å˜ç›¸å‹
0å¼•æ•°ã®ä¸€èˆ¬ã®å˜ç›¸å‹ã‚’æ¬¡ã®ã‚ˆã†ã«è¡¨ã™ã“ã¨ã«ã™ã‚‹ã€‚
```rust
pub enum Type {
    TType(String),
}
```
ã“ã‚Œã«ä¼´ã„ã€Stringã‚„Intãªã©ã‚’`Type::TType("String".to_owned())`ã‚„`Type::TType("Int".to_owned())`ã«æ›¸ãæ›ãˆã‚‹ã€‚

# å‹å®šç¾©ã®å‹æ¨è«–éƒ¨ã§ã®å‡¦ç†
å‹å®šç¾©ã®AST`Statement::TypeDef`ã¯ã€`typeinfer_statement`ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¦æ¬¡ã®ã‚ˆã†ãªå‡¦ç†ãŒãªã•ã‚Œã‚‹ã€‚
```rust
Statement::TypeDef(type_name, constructor_def_vec) => {
    for ConstructorDef { name, args } in constructor_def_vec {
        self.env.borrow_mut().insert(
            name.to_owned(),
            args.iter()
                .rev()
                .fold(Type::ttype(type_name), |acm, ty| t_fun(ty.clone(), acm)),
        )
    }
}
```
å…·ä½“çš„ã«ã¯ã€å‹å®šç¾©ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å„ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‹ç’°å¢ƒã«åŠ ãˆã¦ã„ã‚‹ã€‚
ä¾‹ã¨ã—ã¦ã€æ¬¡ã®ã‚ˆã†ãªå‹å®šç¾©ãŒã‚ã£ãŸå ´åˆã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã‚‹ã€‚
```
enum OptionInt {
    Some(Int),
    None
};
```
ã“ã®å ´åˆã€å‹ç’°å¢ƒã«ã¯`Some`ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å‹`Int -> OptionInt`ã¨`None`ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å‹`OptionInt`ãŒåŠ ãˆã‚‰ã‚Œã‚‹ã€‚

# å‹å®šç¾©ã®è©•ä¾¡éƒ¨ã§ã®å‡¦ç†
ã¾ãšã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’è¡¨ã™å€¤ã‚’å®šç¾©ã™ã‚‹ã€‚
```rust
VConstructor(String, Vec<Value>),
```

ãã—ã¦ã€å‹å®šç¾©ã®AST`Statement::TypeDef`ã®å ´åˆã®å‡¦ç†ã‚’`eval_statement`ãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ ã™ã‚‹ã€‚
```rust
Statement::TypeDef(_, constructor_def_vec) => {
    for ConstructorDef { name, args } in constructor_def_vec {
        self.env.borrow_mut().insert(
            name.to_owned(),
            Value::VConstructor(name.to_owned(), vec![]),
        )
    }
    Ok(())
}
```

ãã—ã¦ã€é–¢æ•°é©ç”¨ã®è©•ä¾¡ã«ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å ´åˆã‚’è¿½åŠ ã—ã¦ãŠãã€‚(ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯`Foo(3)`ã®ã‚ˆã†ã«ä½¿ã‚ã‚Œã‚‹ã®ã§ã€æ§‹æ–‡è§£æã™ã‚‹ã¨é–¢æ•°é©ç”¨ã¨ã—ã¦å‡¦ç†ã•ã‚Œã‚‹ã€‚)

```rust
fn fun_app_helper(&self, v1: Value, v2: Value) -> Result<Value, EvalError> {
    match v1 {
        ...
        Value::VConstructor(name, args) => {
            let mut mut_args = args;
            mut_args.push(v2);
            Ok(Value::VConstructor(name, mut_args))
        }
        _ => Err(EvalError::InternalTypeError),
    }
}
```

# å‹ã®æ§‹æ–‡è§£æ
ã•ã¦ã€ä»Šã®æ‰€å˜ç´”ãªå‹(`Int`ã‚„`Hoge`ç­‰)ã®ã¿ã—ã‹æ§‹æ–‡è§£æå‡ºæ¥ãªã„ã®ã‚’ã€é–¢æ•°ã®å‹ã‚„Vectorå‹ãªã©ã‚’æ§‹æ–‡è§£æå‡ºæ¥ã‚‹ã‚ˆã†ã«ã—ã¦ã„ãã€‚(å‹å¤‰æ•°ã‚’å«ã‚€å‹ã«ã¤ã„ã¦ã¯ã€ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹ã§å‹å¤‰æ•°ã‚’å«ã‚€å‹ãŒå®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹æ‹¡å¼µã‚’æ–½ã™ã¨ãã«ä¸€ç·’ã«æ§‹æ–‡è§£æã‚’å®Ÿè£…ã™ã‚‹ã€‚)

```rust
pub fn parser_type_init(input: &str) -> IResult<&str, Type> {
    parser_fun_type(input)
}

pub fn parser_fun_type(input: &str) -> IResult<&str, Type> {
    let (input, t1) = parser_type(input)?;
    let (input, t2) = opt(|input| {
        let (input, _) = symbol("->")(input)?;
        let (input, t2) = parser_fun_type(input)?;
        Ok((input, t2))
    })(input)?;
    match t2 {
        Some(t2) => Ok((input, Type::TFun(Box::new(t1), Box::new(t2)))),
        None => Ok((input, t1)),
    }
}

pub fn parser_type(input: &str) -> IResult<&str, Type> {
    alt((
        delimited(symbol("("), parser_type_init, symbol(")")),
        parser_ref_type,
        parser_vector_type,
        parser_simple_type,
        parser_unit_type,
    ))(input)
}
```
ã¾ãšã€`parser_type_init`ãŒã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã¨ãªã£ã¦ã„ã‚‹ã€‚ãã—ã¦`parser_fun_type`ã§ã¯é–¢æ•°ã®å‹ã®æ§‹æ–‡è§£æãŒã•ã‚Œã‚‹(->ã¯å³çµåˆ)ã€‚`parser_type`ã§ã¯ã€Unitå‹ã€Vectorå‹ã€Refå‹ã€æ™®é€šã®å‹(`Int`ã‚„`Hoge`ãªã©)ã€æ‹¬å¼§ã§å›²ã‚ã‚ŒãŸå‹ã®æ§‹æ–‡è§£æãŒãªã•ã‚Œã‚‹ã€‚
